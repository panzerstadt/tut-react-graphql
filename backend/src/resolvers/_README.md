resolvers are the actual implementation of the promises that we made when writing the graphql schema

- we promise to return this stuff (in schema)
- so now we gotta do it (in resolvers)

# types

- resolver types should map to your graphql schema, but since there is no official library to generate types, use one of the community methods. [I used this](https://www.npmjs.com/package/graphql-schema-typescript)

- the context argument for the resolver in this case is important, as there is a Prisma type definition to help you map your functions to "ORM" like methods in order to minimize any code needed in your resolver (otherwise you would need to write your own CRUD), especially for simple commands.

```js
const withoutPrisma = {
  updateLink: (parent, args) => {
    if (DB.has(args.id)) {
      const original = DB.get(args.id);
      DB.addToDB(
        args.id,
        args.url || original.url,
        args.description || original.description
      );
      return DB.get(args.id);
    } else {
      return null;
    }
  }
};

const withPrisma = {
  updateLink: (parent, args, context: Context, info) =>
    context.prisma.updateLink({
      // you literally just call a function, with the added bonus of autocomplete generated by prisma!
      data: {
        url: args.url,
        description: args.description
      },
      where: {
        id: args.id
      }
    })
};
```

# ref

- https://www.prisma.io/tutorials/a-guide-to-common-resolver-patterns-ct08/#scenario:-implementing-relations-with-prisma-client
